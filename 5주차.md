# 13-1 인텐트 이해하기
## 인텐트란?
- `intent` : component를 실행하려고 시스템에 전달하는 메시지 (기능 수행 함수를 제공하는 클래스가 아닌, data를 담는 클래스)
  - component를 실행하는 정보가 담긴 intent 객체를 시스템에 전달하면 component가 실행됨
  - 안드로이드의 component 클래스는 시스템이 생성해서 실행하는 클래스이므로 개발자가 작성하는 코드로 생명주기를 관리할 수 없음
    ㄴ 4대 component에 개발자가 작성하는 activity 외에도 broadcast reciever 등이 있으니까 그말인듯...?
    => 따라서 시스템에 intent를 전달해줌 -> 시스템에서 intent의 정보를 분석 -> 그에 맞는 컴포넌트를 실행

  - 외부앱도 마찬가지임
    
---
시스템에 component를 알리기 위해 manifest 파일에 정보를 등록함
- activity는 manifest에 등록해서 사용
  - `<activity>` 태그로 각 activity class를 등록
  - activity 클래스 이름을 지정하는 name 속성은 생략 불가능함
- 4대 component 모두 manifest에 등록해야 함

```kotlin
val intent: Intent = Intent(this, DetailActivity::class.java)
startActivity(intent)
```
- `startActivity()` : intent를 시스템에 전달(시작)함
- `DetailActivity::class.java` : 클래스 타입 referrence 정보

---
## 인텐트 엑스트라 데이터
- 함수를 호출하며 parameter로 데이터를 넘기는 방법 -> 불가능함
  - component 객체는 시스템이 생성하므로 개발자 코드로는 직접 접근할 수 없음
- `extra data`(intent에 담는 부가정보)를 이용하는 방법
  - `MainActivity`에서 intent에 extra data를 추가해서 전달 -> `DetailActivity`에서 intent에 담긴 extra data를 가져옴
  - ```Kotlin
    public Intent putExtra(String name, CharSequence value)
    ```
    
  - intent에 데이터 추가하기
    ```Kotlin
    val intent: Intent = Intent(this, DetailActivity::class.java)
    intent.putExtra("data1", "hello")
    intent.putExtra("data2", 10)
    startActivity(intent)
    ```
  - extra 데이터 가져오기
    ```Kotlin
    val data1 = intent.getStringExtra("data1")
    val data2 = intent.getIntExtra("data2", 0)
    ```
  - 데이터 추가 / 가져오기 모두 여러 타입에 따라 다양하게 가능함

  - 액티비티 화면 되돌리기 - ActivityResultLauncher
    - 사후 처리가 필요 없는 경우
      - 이메일 앱 목록 화면에서 상세보기 화면으로 전환했다가 되돌아왔을 때
      - `startActivity()`
    - 사후 처리가 필요한 경우
      - 카톡 프로필 설정 화면에서 갤러리 앱의 목록을 띄운 후 다시 설정 화면으로 돌아올 때 갤러리에서 사용자가 선택한 사진을 프로필 사진으로 등록해야 하는 경우
      - `startActivityForResult()`, `ActivityResultLauncher` (android ver 11부터 권장)
      - ```Kotlin
        intent.putExtra("resultData", "world")
        setResult(RESULT_OK, intent)
        finish()
        ```
        !!! 기존 방법은 `Activity`에서 `startActivityForResult()`를 통해서 `Callback`으로 등록하고 `onActivityResult`에서 callback을 처리하므로 두 메서드가 같은 곳에서 구현을 해야 하는데 메모리 부족으로 제대로 동작이 안 될 수도 있다 !!!
      - `finish()` 호출 이전에 결과 데이터를 intent 객체에 담을 수 있음
      - `setResult()` : 결과를 어떻게 되돌릴지 지정
        - `RESULT_OK` : 요청을 제대로 처리함
        - `RESULT_CANCELED` : 요청을 제대로 처리하지 않음
        ??? RESULT_CANCELED를 쓰는 경우는 ???

      - `ActivityResultLauncher`를 사용해 액티비티를 실행시키는 방법
        - intent를 발생시켜 화면 전환 -> 되돌아왔을 때 `ActivityResultLauncher` 로 사후 처리하는 방법
        - `Contract` (요청의 실행자) -> `ActivityResultLauncher` (`Contract`와 `Callback` 등록) -> `launch` (요청 발생)
          - `Contract` : `ActivityResultLauncher`로 실행될 요청을 처리하는 역할을 함 (activity를 실행할 때 실제 intent를 발생시키는 역할을 함)
          - `ActivityResultLauncher` : `registerForActivityResult()` 함수로 만드는 객체. 함수의 매개변수에 실제 작업자인 `Contract` 객체와 결과를 처리하는 `Callback` 객체를 등록해줌.
          - `launch` : 호출하는 순간 `ActivityReusltLauncher`에 등록된 `Contract` 객체가 실행됨.
          - `ActivityReusltLauncher` 생성
            ```Kotlin
            val requestLauncher: ActivityResultLauncher<Intent> = registerForActivityResult(
              ActivityResultContracts.StartActivityForResult())
              {
                val resultData = it.data?.getStringExtra("result")
                binding.mainResultView.text = "result : $resultData"
              }
            ```
          ??? Callback 함수는 작성 안 된건가 ???
          !!! 찾아보니 이렇게 작성하는 예시가 있다고 함
          ```Kotlin
          if (it.resultCode == RESULT_OK) {
            val myData: Intent? = it.data
            val address = it.data?.getStringExtra("KEY1") ?: ""
            Log.e(TAG, address)
          }
          ```
          - `ActivityResultLauncher` 실행
            ```Kotlin
            val intent: Intent = (this, DetailActivity::class.java)
            requestLauncher.launch(intent) // 호출하는 순간 ActivityResultLauncher에 등록된 Contract 객체가 실행됨
            ```

 ## 인텐트 필터
- `explicit intent` : 앞 예시처럼 class type referrence를 이용하는 것. 내부 앱의 컴포넌트를 요청하는 intent 객체를 만들 때 사용됨
  - 코드에서 실행할 대상 컴포넌트 : `DetailActivity::class.java` (class type referrence)
  - 같은 앱의 컴포넌트라면 위처럼 사용가능하지만, 외부 앱의 컴포넌트는 이렇게 실행할 수 없음
  ```Kotlin
  val intent: Intent = Intent(this, DetailActivity::class.java)
  ```
  ```Manifest
  <activity android:name=".OneActivity" />
  ```
  - manifest 파일에 activity를 등록 시 name 속성만 지정하면 해당 activity는 explicit intent로만 실행할 수 있음

- `implicit intent` : 외부 앱의 컴포넌트는 class type referrence를 활용할 수 없어 사용함.
  ```Kotlin
  <activity android:name=".OneActivity" />
  <activity
      android:name=".TwoActivity"
      android:exported="true">
      <intent-filter>
          <action android:name="ACTION_EDIT" />
          <category android:name="android.intent.category.DEFAULT" />
      </intent-filter>
  </activity>
  ```
  - 어떤 컴포넌트를 외부에서도 intent로 실행할 수 있게 하려면 해당 컴포넌트가 있는 앱의 manifest 파일에 implicit intent로 실행할 수 있게 `<intent-filter>`를 설정해줘야 함
  - `<intent-filter`는 `<activity>`, `<service>`, `<receiver>` 등 컴포넌트 등록 태그 하위에 작성할 수 있음
  - 추가 시 해당 컴포넌트의 클래스명과 intent filter 정보가 시스템에 등록 / 실행 시 시스템에 등록된 정보에 맞게 intent를 설정함
  - 내부 앱의 컴포넌트도 implicit intent로 실행할 수도 있지만, <intent-filter> 설정 여부와 상관없이 class type referrence로 실행을 권장함
  !!! 설정은 implicit하게 해도 사용은 DetailActivity::class.java 이렇게 쓰라는 말인듯 ~! !!!
